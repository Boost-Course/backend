# 2주차 답변

* 스프링은 왜 싱글톤으로 빈을 관리할까요?  
스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생했습니다. 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 처리하는데, 요청이 올 때마다 객체를 새로 생성하면 메모리 낭비가 심합니다. 따라서 객체를 1개만 생성하고, 이를 공유하도록 하는 싱글톤 패턴을 사용합니다.

* 싱글톤 패턴의 문제점은 무엇이 있나요?  
테스트하기 어렵습니다. 싱글톤 인스턴스를 가짜(Mock) 구현으로 대체할 수 없기 때문입니다.  
의존관계상 클라이언트가 구체 클래스에 의존하므로 DIP(Dependency Inversion Principle)를 위반할 가능성이 있습니다.

* 필드 주입의 장점과 단점에 대해서 설명해주세요.  
장점: 코드가 간결합니다.  
단점: 테스트하기 어렵습니다. 의존성을 직접 주입할 방법이 사라지므로, 단위 테스트 시 mock 객체를 주입하기가 어렵습니다.

* 생성자 주입을 사용하는 것이 좋은 이유에 대해서 알려주세요.  
생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없습니다. 따라서 불변하게 설계할 수 있습니다. 생성자 주입을 사용하면 필드에 `final` 키워드를 사용할 수 있어, 생성자에 값이 설정되지 않는 오류를 컴파일 시점에 막아줍니다.

* 콜백 함수에 대해서 알려주세요.  
콜백 함수는 전달인자로 다른 함수에 전달되어, 특정 동작이 완료된 후 호출되는 함수입니다. 콜백은 **동기(synchronous)** 또는 **비동기(asynchronous)** 방식으로 실행될 수 있습니다.  
**동기 콜백**은 호출된 함수가 완료된 직후 바로 실행되며,  
**비동기 콜백**은 비동기 작업이 완료된 이후 호출됩니다.

* 스프링 빈의 이벤트 라이프사이클에 대해서 알려주세요.  
1. 스프링 컨테이너 생성  
2. 스프링 빈 생성  
3. 의존관계 주입  
4. 초기화 콜백  
5. 빈 사용  
6. 소멸 전 콜백  
7. 스프링 종료  

**초기화 콜백**: 빈이 생성되고 의존관계가 주입된 후 호출됩니다.  
**소멸 전 콜백**: 빈이 소멸되기 직전에 호출됩니다.

* 스프링의 빈 스코프에 대해서 알려주세요.  
**싱글톤**: 기본 스코프. 스프링 컨테이너 시작 ~ 종료까지 유지되는 가장 넓은 범위의 스코프입니다.  
**프로토타입**: 빈이 생성되고 의존관계 주입, 초기화까지만 관여하고, 이후 더는 관리하지 않는 짧은 범위의 스코프입니다.  
**웹 관련 스코프**: 요청 스코프(Request), 세션 스코프(Session), 애플리케이션 스코프(Application) 등이 있습니다.

* 배열과 ArrayList의 차이가 뭘까요?  
배열은 생성 시 크기가 고정되고, 한 번 생성된 배열의 크기는 변경할 수 없습니다. 반면, `ArrayList`는 크기가 가변적이며, 데이터가 추가되거나 제거됨에 따라 크기가 자동으로 조정됩니다.  
**배열**: 기본 타입과 참조 타입 모두 저장 가능  
**ArrayList**: 참조 타입만 저장 가능  
또한 `ArrayList`는 내부적으로 배열을 사용하지만, 크기 조정이 필요한 경우 기존 배열보다 더 큰 배열을 생성해 데이터를 복사합니다.

* 불변 클래스에 대해서 설명해주세요. 어떻게 만들 수 있나요?  
불변 클래스는 인스턴스 생성 후 내부 상태가 절대 변하지 않는 클래스를 의미합니다. 불변 클래스를 만들기 위해서는 다음 규칙을 따릅니다:  
객체의 상태를 변경하는 메서드(변경자)를 제공하지 않습니다.  
클래스를 확장할 수 없도록 합니다.  
모든 필드를 `final`로 선언합니다.  
모든 필드를 `private`으로 선언합니다.  
가변 객체를 포함할 경우, 내부에서 복사본을 생성해 외부에 노출합니다.

* 동일성과 동등성의 차이는 무엇인가요?  
**동일성**: 두 객체가 **같은 메모리 주소**를 참조하는 경우를 말합니다. `==` 연산자를 통해 비교할 수 있습니다.  
**동등성**: 두 객체가 **같은 값을** 갖는 경우를 말합니다. `equals()` 메서드를 재정의해 비교할 수 있습니다.

* == 연산자와 equals 연산자의 차이는 무엇인가요?  
`==` 연산자는 **메모리 주소**를 비교하여 객체의 **동일성**을 판별합니다.  
`equals()` 메서드는 객체의 **값**을 비교하여 **동등성**을 판별합니다. `equals()`는 필요에 따라 재정의할 수 있습니다.

* @Controller 안에는 @Component가 들어있어서 컴포넌트 스캔의 대상이 됩니다. 그런데 애노테이션에는 상속관계라는 것이 없습니다. 애노테이션이 특정 애노테이션을 들고 있는 것을 인식할 수 있는 것은 스프링이 지원하는 기능인데 어떻게 이것이 가능할까요?  
스프링은 애노테이션을 **메타 애노테이션**으로 지원합니다. 즉, 하나의 애노테이션이 다른 애노테이션을 포함할 수 있습니다. `@Controller`는 `@Component`를 메타 애노테이션으로 포함하고 있기 때문에, 스프링은 `@Controller`를 `@Component`로 인식하여 컴포넌트 스캔의 대상으로 처리할 수 있습니다.

* @Repository는 데이터 계층의 예외를 스프링 예외로 변환해주는 역할을 하는데, 구체적으로 어떻게 동작하나요?  
`@Repository`는 **데이터 액세스 계층**에서 발생하는 **예외를 스프링의 `DataAccessException`으로 변환**해주는 역할을 합니다. JDBC 등에서 발생하는 체크 예외들을 런타임 예외로 변환하여, 비즈니스 로직이 예외 처리를 쉽게 할 수 있도록 해줍니다.

* enum 타입 비교할때 equals말고 == 하는 이유  
`enum`은 **상수**이므로 **참조 비교**(==)를 사용하는 것이 적절합니다. `equals()`를 사용하면 `null` 체크가 필요할 수 있지만, `==`를 사용할 경우 컴파일 시점에 타입 체크가 이루어져서 더 안전합니다.

* String 문자열의 값을 비교할 때는 equals를 사용하는 이유는?  
`String` 객체는 리터럴로 생성되거나 `new`로 생성될 수 있는데, 두 방식이 메모리에서 다르게 처리됩니다. `equals()`는 **값을 비교**하는 메서드로, 문자열의 실제 내용을 비교하기 위해 사용됩니다. 반면, `==`는 **참조 비교**로 메모리 주소를 비교하기 때문에 리터럴이 아닌 `String` 객체를 비교할 때는 `equals()`를 사용해야 정확한 결과를 얻을 수 있습니다.

* 자바 접근 제어자에 대해서 말해주세요  
`public`: 모든 클래스에서 접근 가능  
`private`: 해당 클래스 내부에서만 접근 가능  
`protected`: 같은 패키지 또는 상속받은 클래스에서만 접근 가능  
패키지-프라이빗(default): 같은 패키지 내에서만 접근 가능

* 배열의 장단점은?  
장점: 배열은 **인덱스를 사용한 빠른 데이터 접근**이 가능하며, 시간 복잡도는 O(1)입니다.  
단점: **중간 데이터 삽입과 삭제** 시 데이터 전체를 이동시켜야 하므로 성능 저하가 발생할 수 있으며, 시간 복잡도는 O(n)입니다.

* ArrayList에 대해서 설명해주세요  
`ArrayList`는 **크기가 동적으로 변하는 배열** 기반의 자료구조로, `List` 인터페이스의 구현체입니다. 각 요소는 인덱스로 접근 가능하며, 필요에 따라 크기를 자동으로 조정합니다. 그러나 데이터를 삽입하거나 삭제할 때 **크기 조정**이 필요할 경우 성능 저하가 발생할 수 있습니다.

* 해시테이블에 대해 설명해주세요  
해시테이블은 **해시 함수를 통해 도출된 키의 해시 값을 인덱스로 사용**하여 값을 저장하는 자료구조입니다. 이 방식은 데이터의 **평균 접근, 삽입, 삭제 시간이 O(1)**인 빠른 성능을 제공합니다. 다만, 해시 충돌이 발생할 수 있어 충돌 해결 방법이 필요합니다.

* 스프링 빈을 수동으로 등록할 때 @Configuration - @Bean 이렇게 말고 @Configuration을 제거하면 어떻게 되나요?  
`@Configuration`을 사용하면 **CGLIB** 프록시를 통해 싱글톤이 보장됩니다. `@Configuration`을 제거하면 프록시가 생성되지 않고, `@Bean` 메서드 호출 시 **매번 새로운 인스턴스**를 반환하게 됩니다. 즉, 싱글톤 보장이 깨지게 됩니다.

* 빈 스코프 싱글톤과 프로토타입의 차이에 대해서 말해주세요  
**싱글톤 스코프**: 스프링 컨테이너 시작부터 종료까지 **빈의 인스턴스가 1개만 유지**됩니다.  
**프로토타입 스코프**: 빈이 요청될 때마다 **새로운 인스턴스가 생성**되며, 생성 후 스프링 컨테이너는 해당 빈을 관리하지 않습니다.

* 의존관계 주입 시 필드 주입보다 생성자 주입을 추천하는 이유는?  
생성자 주입을 사용하면 **불변성을 보장**할 수 있으며, 프레임워크에 의존하지 않고 **순수한 자바 코드로 테스트 가능**합니다. 또한, **의존성 누락을 컴파일 시점에 체크**할 수 있습니다.

* 에러와 예외의 차이는?  
**에러**: 시스템이 종료되어야 할 정도로 심각한 문제로, 개발자가 미리 예측하기 어려운 경우가 많습니다.  
**예외**: 개발자가 작성한 코드로 충분히 **수습**할 수 있는 문제로, 예외 처리를 통해 프로그램이 정상적으로 동작할 수 있습니다.

* @Repository의 부가기능을 스프링 데이터 접근 계층으로 인식하고 데이터 계층의 예외를 스프링 예외로 변환해준다는 기능이 있는데, 데이터 계층의 예외를 스프링 예외로 변환해주는 이유가 뭔가요?  
JDBC 등의 데이터 접근 기술에서 발생하는 **Checked Exception**(예: `SQLException`)을 스프링이 제공하는 **`DataAccessException`**으로 변환하여 **Unchecked Exception**으로 처리합니다. 이는 **비즈니스 로직**에 불필요한 예외 처리를 피하게 하여, 코드 가독성과 유지보수성을 높여줍니다.

* 실무에서 system.out.println() 쓰지말고 로그 쓰라고 하는 이유는?  
1. `System.out.println()`은 **synchronized**가 걸려 있어 성능 저하를 유발할 수 있습니다.  
2. 로그는 출력 시각, 위치, 로그 레벨 등의 **부가 정보**를 제공하며, **레벨에 따른 로그 관리**가 가능합니다.  
3. 로그는 **파일로 기록**될 수 있어 **지속적인 관리**가 가능하지만, `System.out.println()`은 휘발성입니다.

* 클래스 로딩에 대해 설명해주세요.  
클래스 로딩은 JVM(Java Virtual Machine)이 클래스를 실행하기 위해 **바이트코드로 변환된 클래스 파일을 메모리에 로드**하는 과정입니다.  
1. **로딩(Loading)**: 클래스 파일을 메모리에 읽어들이고, `Method Area`에 클래스 정보를 저장합니다.  
2. **링크(Linking)**: 클래스 내부의 메타데이터를 확인하고 참조를 연결합니다.  
3. **초기화(Initialization)**: 클래스 변수(`static` 변수)를 초기화하고, 클래스의 정적 초기화 블록을 실행합니다.

* 각기 다른 스레드나 메서드 호출 간에 공유되지 않는 변수들은 어떤 것이 있는지 설명해주세요.  
**지역 변수(Local Variables)**: 메서드 내에서 선언된 변수로, 메서드 실행 시 생성되고 종료되면 소멸합니다. 다른 스레드나 메서드에서 공유되지 않습니다.  
**스레드 로컬 변수(ThreadLocal)**: 각 스레드가 독립적으로 사용할 수 있는 변수로, 스레드마다 고유한 값을 가집니다. 다른 스레드와 값을 공유하지 않습니다.

* 지역 변수와 인스턴스 변수의 차이는?  
**지역 변수**: 메서드 내에서 선언되며, 해당 메서드가 실행될 때 생성되고 종료 시 소멸합니다.  
**인스턴스 변수**: 클래스의 인스턴스에 속하며, 객체가 생성될 때 함께 생성되고 객체가 참조되지 않으면 소멸합니다.

* Java의 GC에 대해 설명해 주세요.  
Java의 **Garbage Collection(GC)**는 **더 이상 참조되지 않는 객체**들을 자동으로 메모리에서 제거하는 메모리 관리 기법입니다. GC는 Young Generation과 Old Generation을 관리하며, 필요할 때마다 실행됩니다. GC가 실행되면 **Stop-the-world** 이벤트가 발생하여, 프로그램이 일시적으로 중단될 수 있습니다.

* Call by reference란 무엇이고 보통 어떻게 쓰이나요?  
**Call by reference**는 메서드 호출 시 변수의 **메모리 주소**를 전달하는 방식입니다. 이 방식에서는 메서드 내부에서 원본 데이터에 접근하여 변경할 수 있습니다.  
Java에서는 **Call by value**만 존재하지만, 객체 참조의 경우 **참조 값을 복사**하여 전달합니다. 이는 참조된 객체의 상태를 변경할 수 있게 해줍니다.

* final 키워드를 사용하면, 어떤 이점이 있나요?  
**변경 불가성(불변성)**: `final`로 선언된 변수는 한 번 초기화되면 변경할 수 없습니다.  
**성능 최적화**: `final` 메서드는 **오버라이드**되지 않으므로, 더 빠르게 실행될 수 있습니다.  
**안전성**: 의도치 않은 값 변경을 방지해 **코드 안정성을 높일 수 있습니다**.